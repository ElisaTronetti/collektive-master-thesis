{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThe main constructs provided by the field calculus are the following: nbr-expression |hello| is ;\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThe main constructs provided by the field calculus are the following: nbr-expression \\E(?:Dummy|Ina|Jimmy-)[0-9]+$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThis allows the field to change dynamically: if in the previous round the rep expression has not been evaluated, the initialization value is \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, otherwise it is the value obtained in the last computation of rep; Nbr-expression \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qif(e_0)e_1 else e_2 \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qe(e_1, ..., e_n)\\E$"}
{"rule":"SENTENCE_WHITESPACE","sentence":"^\\QUnit.\\E$"}
{"rule":"BEEN_PART_AGREEMENT","sentence":"^\\QThe IrGenerationExtension implemented method is generate, which is\\E$"}
{"rule":"BEEN_PART_AGREEMENT","sentence":"^\\QThe IrGenerationExtension implemented method is generate, and it is shown in Listing \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"PHRASE_REPETITION","sentence":"^\\QAvailable in KotlinNative Available in KotlinJS Available in KotlinJVM Allows same target interoperability Allows different targets interoperability Accettable efficiency Stacktrace yes yes yes yes no no Hashes yes no yes no no yes\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QAvailable in KotlinNative Available in KotlinJS Available in KotlinJVM Allows same target interoperability Allows different targets interoperability Stacktrace yes yes yes yes no Hash yes no yes no no\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QAvailable in KotlinNative Available in KotlinJS Available in KotlinJVM Allows same target interoperability Allows different targets interoperability Stacktrace yes yes yes yes no Hash yes no yes no no Comparison between stacktrace and hash for solving the alignment problem\\E$"}
{"rule":"PHRASE_REPETITION","sentence":"^\\QAvailable in KotlinNative Available in KotlinJS Available in KotlinJVM Allows same target interoperability Allows different targets interoperability Stacktrace yes yes yes yes no Hash yes no yes no no Comparison between stacktrace and hash for solving the alignment problem\\E$"}
{"rule":"PHRASE_REPETITION","sentence":"^\\QAvailable in KotlinNative Available in KotlinJS Available in KotlinJVM Allows same target interoperability Allows different targets interoperability Stacktrace yes yes yes yes no Hash yes yes yes no no Comparison between stacktrace and hash for solving the alignment problem\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QAvailable in KotlinNative Available in KotlinJS Available in KotlinJVM Allows same target interoperability Allows different targets interoperability Stacktrace yes yes yes yes no Hash yes yes yes no no Comparison between stacktrace and hash for solving the alignment problem\\E$"}
{"rule":"ADVERB_VERB_ADVERB_REPETITION","sentence":"^\\QAvailable for Kotlin Multiplatform Allows same target interoperability Allows different targets interoperability Acceptable efficiency Transparent to the final user Stacktrace yes yes no no yes Hash yes no no yes yes Annotation yes yes (manually) yes (manually) yes no KSP yes yes (manually) yes (manually) yes no Comparison between stacktrace and hash for solving the alignment problem\\E$"}
{"rule":"ADVERB_VERB_ADVERB_REPETITION","sentence":"^\\QAvailable for Kotlin Multiplatform Allows same target interoperability Allows different targets interoperability Acceptable efficiency Transparent to the final user Stacktrace yes yes no no yes Hash yes no no yes yes Comparison between stacktrace and hash for solving the alignment problem\\E$"}
{"rule":"ADVERB_VERB_ADVERB_REPETITION","sentence":"^\\QAvailable for Kotlin Multiplatform Allows same target interoperability Allows different targets interoperability Acceptable efficiency Transparent to the final user Stacktrace yes yes no no yes Hash yes no no yes yes Annotation no - - - - KSP yes yes (manually) yes (manually) no no Comparison between stacktrace, hash, annotation and KSP for solving the alignment problem\\E$"}
{"rule":"ADVERB_VERB_ADVERB_REPETITION","sentence":"^\\QAvailable for Kotlin Multiplatform Allows same target interoperability Allows different targets interoperability Acceptable efficiency Transparent to the final user Stacktrace yes yes no no yes Hash yes no no yes yes Annotation no yes (manually) yes (manually) - no KSP yes yes yes no yes Comparison between stacktrace, hash, annotation and KSP for solving the alignment problem\\E$"}
{"rule":"ADVERB_VERB_ADVERB_REPETITION","sentence":"^\\QAvailable for Kotlin Multiplatform Allows same target interoperability Allows different targets interoperability Acceptable efficiency Transparent to the final user Stacktrace yes yes no no yes Hash yes no no yes yes Annotation no yes (manually) yes (manually) yes no KSP yes yes yes no yes Comparison between stacktrace, hash, annotation and KSP for solving the alignment problem\\E$"}
{"rule":"PHRASE_REPETITION","sentence":"^\\QAvailable for Kotlin Multiplatform Allows same target interoperability Allows different targets interoperability Acceptable efficiency Transparent to the final user Stacktrace yes yes no no yes Hash yes no no yes yes Annotation no yes (manually) yes (manually) yes no KSP yes yes yes no yes KCP yes yes yes yes yes Comparison between stacktrace, hash, annotation, KSP and Kotlin compiler plugin for solving the alignment problem\\E$"}
{"rule":"ADVERB_VERB_ADVERB_REPETITION","sentence":"^\\QAvailable for Kotlin Multiplatform Allows same target interoperability Allows different targets interoperability Acceptable efficiency Transparent to the final user Stacktrace yes yes no no yes Hash yes no no yes yes Annotation no yes (manually) yes (manually) yes no KSP yes yes yes no yes KCP yes yes yes yes yes Comparison between stacktrace, hash, annotation, KSP and Kotlin compiler plugin for solving the alignment problem\\E$"}
{"rule":"THE_PUNCT","sentence":"^\\QThe Kotlin compiler plugin architecture \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q Figure \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q shows the first evaluation of conditions is a, and, only if that it is true then it is evaluated a && b.\\E$"}
{"rule":"THE_SENT_END","sentence":"^\\QThis creates the chance to align b based on the evaluation of a.\\E$"}
{"rule":"THE_PUNCT","sentence":"^\\QThe IR of a branch with multiple condition shown in Listing \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q The Figure \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q shows that a branch is handle like follows: The first branch of the if evaluates the condition a; If a is true, then it is evaluated the condition b.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QThis creates the chance to align b based on the evaluation of a, because after the evaluation of a the stack is [[a,true]], which means that b align only with the neighbors that evaluated a as true; After obtaining both the result of a and b, it is calculated the value of a && b; If the full condition is evaluated as true, the stack is [a && b, true]; Then it is computed function(), which is aligned based on the stack just created.\\E$"}
{"rule":"THE_PUNCT","sentence":"^\\QThis creates the chance to align b based on the evaluation of a, because after the evaluation of a the stack is [[a,true]], which means that b align only with the neighbors that evaluated a as true; After obtaining both the result of a and b, it is calculated the value of a && b; If the full condition is evaluated as true, the stack is [a && b, true]; Then it is computed function(), which is aligned based on the stack just created.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QThe IR of a branch with multiple condition shown in Listing \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q The Figure \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q shows that a branch is handle like follows: The first branch of the if evaluates the condition a; If a is true, then it is evaluated the condition b.\\E$"}
{"rule":"DT_DT","sentence":"^\\QThis creates the chance to align b based on the evaluation of a, because after the evaluation of a the stack is [[a,true]], which means that b align only with the neighbors that evaluated a as true; After obtaining both the result of a and b, it is calculated the value of a && b; If the full condition is evaluated as true, the stack is [a && b, true]; Then it is computed function(), which is aligned based on the stack just created.\\E$"}
{"rule":"THE_PUNCT","sentence":"^\\QThis creates the chance to align b based on the evaluation of a, because after the evaluation of a the stack is [[a, true]], which means that b align only with the neighbors that evaluated a as true; After obtaining both the result of a and b, it is calculated the value of a && b; If the full condition is evaluated as true, the stack is [a && b, true]; Then it is computed function(), which is aligned based on the stack just created.\\E$"}
{"rule":"DT_DT","sentence":"^\\QThis creates the chance to align b based on the evaluation of a, because after the evaluation of a the stack is [[a, true]], which means that b align only with the neighbors that evaluated a as true; After obtaining both the result of a and b, it is calculated the value of a && b; If the full condition is evaluated as true, the stack is [a && b, true]; Then it is computed function(), which is aligned based on the stack just created.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QThis creates the chance to align b based on the evaluation of a, because after the evaluation of a the stack is [[a, true]], which means that b align only with the neighbors that evaluated a as true; After obtaining both the result of a and b, it is calculated the value of a && b; If the full condition is evaluated as true, the stack is [a && b, true]; Then it is computed function(), which is aligned based on the stack just created.\\E$"}
{"rule":"AS_IS_VBG","sentence":"^\\QThis means that the neighboring function align only whenever the condition of the if is true, meaning that it is higher than 5; After the computation of neighboring, it is popped from the stack, leaving again only [[number > 5, true]]; Finally, the body of the if has been successfully executed and the stack can be cleared.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QDSLs can be implemented in a number of ways, including as standalone programming languages, as libraries that extend existing programming languages, or as annotations or macros that modify the syntax or behavior of an existing language.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QDSLs can be used to provide a higher level of abstraction over complex systems or processes, allowing developers to express ideas and concepts in a more concise and intuitive way.\\E$"}
{"rule":"DT_DT","sentence":"^\\QA context receiver allows the block of code to access the properties and functions of the receiver object using the this keyword, without having to explicitly specify the receiver object in the code.\\E$"}
