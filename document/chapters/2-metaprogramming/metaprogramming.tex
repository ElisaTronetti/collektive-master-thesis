\chapter{Metaprogramming in Kotlin}\label{chapter:metaprogramming}
A typical program computation can be summarized as follows: it reads data as input, computes that data and generates an output. Metaprograms \cite{metaprogramming_introduction} are able to take as input another program, sometime even itself, manipulate it and return it with a modified behavior.\newline
Metaprogramming in Kotlin is a powerful feature that allows for the manipulation and generation of code at compile time. The possible benefits of this technique are:
\begin{itemize}
    \item Code generation: it generates repetitive or boilerplate code automatically, reducing the amount of code that needs to be written and maintained by hand. Consequently, this can increase code readability and maintainability, as well as reduce the risk of introducing bugs or errors;
    \item Readability: it provides a higher level of abstraction, allowing to abstract away complex logic and make code more readable and easier to understand. This can also help to simplify the implementation of complex algorithms and data structures;
    \item Reusability: by generating code automatically, it is possible reuse the same logic across multiple parts of applications, increasing overall code reuse and maintainability;
    \item Supports Domain-Specific Languages (DSLs): it enables to create custom, domain-specific languages (DSLs) that are optimized for specific tasks or use cases, which can help to simplify complex operations and make the code more readable and intuitive;
    \item Custom annotations: it allows creating custom annotations, which can be used to provide additional information about the code and to automate tasks such as code generation. This can improve code quality and make it easier to understand the intention behind the code.
\end{itemize}

\section{Metaprogramming techniques}
There are different techniques that can be used in Kotlin in order to create metaprograms. In the following sections they are going to be analyzed in details the main approaches provided by Kotlin, in order to give an overview of the possible alternatives when coming into terms with metaprogramming.

\subsection{Annotations}
Annotations \cite{annotation_documentation} in Kotlin are a type of metadata that can be added to provide additional information about the code, as well as to automate certain tasks.\newline
An annotation is represented by an \textbf{@} symbol followed by the annotation type.

To create a custom annotation in Kotlin, first it is necessary to declare the annotation type, using the \textbf{annotation} keyword in Kotlin, in the same way shown in the following code:
\begin{lstlisting}[caption={Example of creation of a custom annotation in Kotlin}, language=Kotlin, captionpos=b, label={code:kotlin_annotations_creation}]
annotation class MyAnnotation
\end{lstlisting}

Kotlin provides the option to use additional attributes by annotating the annotation class with \textbf{meta-annotation}. The alternatives of meta-annotation are:
\begin{itemize}
    \item \textbf{@Target}: it is used to specify the elements that can be annotated with the annotations, which can be classes, functions, properties and expressions;
    \item \textbf{@Retention}: it defines if an annotation is stored in the compiled class files and if it is visible at runtime using reflections;
    \item \textbf{@Repeatable}: it allows an annotation to be used on an element multiple times;
    \item \textbf{@MustBeDocumented}: it can be used when the annotation is part of a public API, and it must be included in the generated API documentation.
\end{itemize}

For example, this is a possible custom annotation that uses meta-annotation:
\begin{lstlisting}[caption={Example of custom annotation in Kotlin}, language=Kotlin, captionpos=b, label={code:kotlin_annotations_customization}]
@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
annotation class MyAnnotation
\end{lstlisting}
In this snippet of code, the \textbf{@Target} annotation specifies the elements that the annotation can be applied to, in this case either classes or functions. The \textbf{@Retention} annotation refers to the retention policy, which determines that the annotation is available at runtime.

Annotations can be used to provide metadata, such as the purpose of a function, the intended usage of a class, or the preferred behavior of a method. One possible use case is to use annotations to specify that a certain method should only be called on a background thread, or that a certain class is serializable.

Another feature provided by annotations, which is considered metaprogramming, is the possibility to used them to automate tasks, such as code generation. For example, annotations can be used to automatically generate code for serializing and deserializing objects.

It is possible to use the annotation in the code by placing the \textbf{@} symbol, followed by the annotation type before the element that is going to be annotated, such as a class, function, or property.\newline
The following snippet of code shows how to actually use a custom annotation, specifically the one created in Listing \ref{code:kotlin_annotations_customization}:
\begin{lstlisting}[caption={Example of usage of a custom annotation in Kotlin}, language=Kotlin, captionpos=b, label={code:kotlin_annotations_usage}]
@MyAnnotation
class MyClass

fun myFunction() {
    @MyAnnotation
    val myVariable = 42
}
\end{lstlisting}
In this example, the \textbf{MyAnnotation} annotation is applied to both a class and a variable. The annotations can be used by other code, either at compile time or at runtime, to provide additional information about the annotated elements.

\subsection{KSP}
KSP stands for \textbf{Kotlin Symbol Processing}, and it is an API that can be used to build lightweight compiler plugins \cite{ksp_documentation}. It offers an easier compiler plugin API that takes advantage of Kotlin's capabilities, but it keeps the learning curve low.

KSP has been developed as an alternative technology to kapt \cite{kapt_documentation}, which was used to allow annotation processing. Currently, kapt is in maintenance mode; it is being kept up-to-date with the new Kotlin and Java releases, without adding any features.\newline
In comparison to kapt, annotation processors that utilize KSP can be executed two times quicker.

Kotlin Symbol Processing is a feature of the Kotlin compiler that allows to manipulate the code at compile time by processing the symbols of the code. Because of that, it is possible to write metaprogramming code that analyze, transform, and generate other code, without the need to access the code at runtime.

This API allows processing Kotlin programs in a native way, with an understanding of Kotlin-specifc features, which includes extension functions, local functions and declaration-site variance. It models types explicitly, which enables type checking.

KSP models the structure of Kotlin programs, making class declarations, class members, functions and parameters accessible for processing, while elements such as if blocks and for loops are not.\newline
It can also be seen as a preprocessor framework, which makes a KSP plugin a symbol processor that follow three main steps:
\begin{enumerate}
    \item it analyzes the source program and its resources;
    \item it generates an output, which might be code or in another form;
    \item finally, the Kotlin compiler compiles the source program with the generated output.
\end{enumerate}

Differently from a typical compiler plugin, KSP restricts processors from modifying the source code, as it is considered read-only. This choice can be justified by the intention to prevent confusion that may arise from a plugin that modifies the language semantics.

When analyzing the source code, from the KSP perspective, it looks like this:
\begin{lstlisting}[caption={The source code from KSP perspective \cite{ksp_documentation}}, captionpos=b, label={code:ksp_source_code}]
KSFile
  packageName: KSName
  fileName: String
    declarations: List<KSDeclaration>
      KSClassDeclaration //class, interface, object
        simpleName: KSName
        qualifiedName: KSName
        containingFile: String
        typeParameters: KSTypeParameter
        parentDeclaration: KSDeclaration
        classKind: ClassKind
        primaryConstructor: KSFunctionDeclaration
        superTypes: List<KSTypeReference>
        //contains inner classes, functions, properties
        declarations: List<KSDeclaration>    
\end{lstlisting}
The Listing \ref{code:ksp_source_code} shows the data structure that is accessible using KSP. Specifically, in this code there is a class declaration (\textit{KSClassDeclaration}), and it is possible to get its name, type, parameters, inner declarations, and so on. This allows to have a complete overview of the code structure.

Two are the elements that KSP expects to be implemented: the \textbf{SymbolProcessorProvider} and the \textbf{SymbolProcessor}.\newline
The SymbolProcessorProvider interface is define like this:
\begin{lstlisting}[caption={SymbolProcessorProvider interface \cite{ksp_documentation}}, language=Kotlin, captionpos=b, label={code:symbol_processor_provider_interface}]
interface SymbolProcessorProvider {
    fun create(environment: SymbolProcessorEnvironment):
        SymbolProcessor
}
\end{lstlisting}
It must be implemented in order to be able to create a SymbolProcessor: because of that, the \textit{create} function is invoked when KSP creates an instance of the SymbolProcessor. The SymbolProcessorProvider is separated from the SymbolProcessor to give more freedom during the development.

This is the interface of the SymbolProcessor:
\begin{lstlisting}[caption={SymbolProcessor interface \cite{ksp_documentation}}, language=Kotlin, captionpos=b, label={code:symbol_processor_interface}]
interface SymbolProcessor {
    fun process(resolver: Resolver): List<KSAnnotated>
}
\end{lstlisting}
The only function that needs to be overridden is \textit{process}, which is typically used to read files and pass the elements to the visitors.\newline
The \textit{Resolver} is the entry point of the functionalities provided by KSP: it can be used, for example, to get all the files of the source code, the symbols with annotation, a class or a function declaration by name.\newline
As many other compiler related APIs, KSP supports the \textbf{visitor pattern}, allowing to examine each element in an object-oriented way.\newline
For example, this is an implementation of a visitor that inspects the declarations, and it collects the functions:
\begin{lstlisting}[caption={Visitor that collects function declarations \cite{ksp_documentation}}, language=Kotlin, captionpos=b, label={code:ksp_visitor}]
class FindFunctionsVisitor: KSTopDownVisitor<Unit, Unit>() {
    override fun visitFunctionDeclaration(
        function: KSFunctionDeclaration,
        data: Unit
    ) {
        functions.add(function.toString())
    }
}
\end{lstlisting}

In conclusion, one of the biggest strength of KSP is that it provides an API built on top of the compiler plugin: for this reason, it is able to hide the compiler changes, minimize maintenance efforts, and its API makes possible to implement a light-weight compiler plugin without the complexities and the knowledge required to create a real compiler plugin.\newline
On the other hand, since the goal of KSP is to be a simple solution for common problems, it comes with some limitations \cite{ksp_limitations}:
\begin{itemize}
    \item it can not examine expression-level information;
    \item it can not modify the source code, but it can only generate new code;
    \item it is not integrated with the IDE, meaning that the IDE has any information about the code generated.
\end{itemize}

\subsection{Kotlin compiler plugins}
Kotlin compiler plugins \cite{compiler_plugins_jetbrains} are a way to extend the functionality of the Kotlin compiler by adding custom processing to the compilation. This means that the compiler plugin code runs at compile-time, and, since this is a feature of \textit{kotlinc}, it only works on Kotlin source code.

Compiler plugins allow automating tasks and enforce coding standards. For example, they can be used to generate boilerplate code, such as accessor methods, or to enforce specific naming conventions or coding styles. Compiler plugins can also be used to perform code analysis and modification, such as adding custom checks and warnings, or refactoring the code automatically.

Kotlin compiler provides a powerful API, which makes it possible to even modify the internals of functions and classes. This enables to solve metaprogramming problems that were impossible using annotation processors, for example with KSP. Another advantage is that compiler plugins work on every Kotlin target, without having to write multiple plugin.

However, it is important to be aware of the potential downsides of using Kotlin compiler plugins. One of the main cons is that to write even a really simple plugin, it is necessary to have compiler background knowledge. Because of the high learning curve, it is important to consider very carefully if it is necessary to develop a plugin. The investment of time and work can be significant: other than understanding how a compiler plugin works, it is necessary to develop:
\begin{itemize}
    \item An IntelliJ plugin: whenever they are used synthetics members, such as functions that are going to be created by the plugin at compile time, the IntelliJ plugin is used to avoid error highlights, making it understand what is going on;
    \item A Gradle or Maven plugin: in order to make the user able to use and configure the compiler plugin;
    \item The actual compiler plugin.
\end{itemize}

Moreover, compiler plugins can slow down the compilation process and make it more complex. Additionally, they can have compatibility issues with different versions of the Kotlin compiler, and may require significant effort to maintain and update. It is also worth mentioning that because compiler plugins modify the behavior of the compiler, they can potentially introduce bugs and cause compatibility issues with other plugins.

Finally, another aspect that must be taken in consideration is the fact that the Kotlin compiler API is not documented. This means that working with it and understanding the function's behaviors is not an easy task, and it requires even more time.

\subsubsection{Basics}
A Kotlin compiler plugin architecture is organized as it can be seen in Figure \ref{fig:kotlin_compiler_plugin_architecture}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.8]{document/chapters/2-metaprogramming/images/kotlin_compiler_plugin_architecture.png}
    \caption{The Kotlin compiler plugin architecture \cite{compiler_plugins_jetbrains}}
    \label{fig:kotlin_compiler_plugin_architecture}
\end{figure}

\subsubsection{Advanced features}
\subsubsection{Example}
