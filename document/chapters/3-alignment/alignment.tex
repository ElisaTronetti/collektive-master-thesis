\chapter{Transparent alignment in Kotlin}\label{chapter:alignment}
The alignment, discussed in Section \ref{subsection:alignment}, is a crucial feature that is necessary to provide in order to create a working implementation of the \textbf{Aggregate programming} paradigm. 

The first step for finding a solution of a problem is to define a simple use case, which is going to be the base of the resolution attempts. A good starting point is code in Listing \ref{code:first_alignment_code_example}, which was also discussed previously in Section \ref{subsection:alignment}. In order to be coherent with the final solution, the code is now written in Kotlin and the nbr-expression is now called \textit{neighboring}.
\begin{lstlisting}[caption={Starting point code to resolve the alignment problem}, captionpos=b, language=Kotlin, label={code:first_alignment_code_example}]
fun f1() {neighboring(e1)}
fun f2() {neighboring(e1)}
        
f1()
f2()
\end{lstlisting}
The goal that needs to be achieved is to find an alignment solution that is able to keep track of the current computational state of a device, making it possible to align only the correct expressions with each other. In this example, it is necessary to find a unique way to identify the execution of the neighboring expression in the body of the \textit{f1} function from the one in the \textit{f2} function.\newline
It is not considered right now the computing device identification, since it is not a core problem in these attempts. Once the base case is solved, then further complexities of the alignment problem are going to be analyzed, such as the branch construct.

There are key aspects that are considered for this study and that are used to compare the different approaches:
\begin{itemize}
    \item \textbf{Availability for Kotlin multiplatform}: it is important to keep in mind that DSL is developed by using Kotlin multiplatform, which choice is discussed in Section \ref{section:technology_choices}. The approaches chosen must be available for a Kotlin multiplatform architecture;
    \item \textbf{Portability}: the alignment solution has to work for all the targeted platforms by Kotlin Multiplatform, which are Native, JavaScript and JVM. Multiple device computing on the same platform have to be able to align correctly;
    \item \textbf{Interoperability}: the solution should allow devices executing on different platform to align;
    \item \textbf{Efficiency}: one aspect to consider is the efficiency, because it can not be produced an elaborated solution that has high computational requirements;
    \item \textbf{Transparency}: finally, this feature has to be transparent to the final user, without making the developer write ulterior code to make the alignment work.
\end{itemize}

Different approaches have been tried to find a solution, and, in each attempt a different problem has been found. The following sections analyze all the possibilities taken in consideration: Section \ref{section:stacktraces_hashes} goes into details of the attempts with stacktraces and hashes, Section \ref{section:annotation_ksp} exploit the problem with annotations and KSP, understanding their limits. Finally, Section \ref{section:compiler_plugin_solution} describes in details the solution adopted, by developing a Kotlin compiler plugin. In each section there is a table that recaps the characteristics for each technology tried for the alignment based on the key aspects highlighted previously.

\section{Stacktraces and hashes}\label{section:stacktraces_hashes}
Since the alignment problem is quite complex, the firsts attempts regards simple strategies without the concern of efficiency, trying to use already existing Kotlin functionalities to generate a unique identifier.

One way of keeping track of the functions called during a program execution is by checking the \textbf{stacktrace}. This leads to one of the possible solutions, which is throwing exceptions whenever an aggregate programming construct is computed, and then using the generated exception stacktrace as identifier.\newline
The stacktraces can be generated in all the platforms that the DSL aims to target. On each platform, the stacktrace is identical for every program execution, meaning that it is possible to align different devices that are executing the same program on the same target.\newline
Moreover, this solution is offers transparency to the final user, because the alignment can work without having the developer to write additional code.\newline
On the other hand, this option presents two main problems that can not be avoided:
\begin{enumerate}
    \item The first problem regards the efficiency of this solution. Since an aggregate program runs continuously on each computing device, an enormous amount of exception would be thrown, causing delays that in a distributed system can cause issues;
    \item The second problem refers to the interoperability of device computing on different targeted platforms. The stacktraces generated by the Native target are completely different from the one generated by JavaScript and JVM, and they represent information in a non-identical way. This means that devices running on different platforms can not align correctly, since the identifier generated for the sequence of the functions called does not match.
\end{enumerate}

Following a similar line of reasoning, the next attempt involved the \textbf{hash-codes}. Kotlin provides a method that given an object returns its hash-code, and it is guaranteed that the hash-code generated is always the same whenever two objects are equal to each other. In order to take advantage of this feature, it was created a new class called \textit{Event}, which has the role to encapsulate the DSL expression that was currently being computed by a device, and then use the object hash-code as identifier. In general, this is not a suitable solution: the hash generated is the same during a single execution, but it is not when running multiple devices that have to communicate, meaning that the alignment can not be achieved, since the identifiers can be different even though they should not be.\newline
This issue is present also when try to align devices running on different platforms, but there is an additional problem: the hash-code generated from a target is not the same in another target, creating a discrepancy impossible to overcome.

\begin{table}[!ht]
    \small
    \centering
    \begin{tabular}{|l|c|c|c|c|c|}
    \hline
    \textbf{} &
      \begin{tabular}[c]{@{}c@{}}Available for\\ Kotlin \\ Multiplatform\end{tabular} &
      \begin{tabular}[c]{@{}c@{}}Allows\\ same target\\ interoperability\end{tabular} &
      \begin{tabular}[c]{@{}c@{}}Allows\\ different targets\\ interoperability\end{tabular} &
      \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Acceptable\\ efficiency\end{tabular}} &
      \begin{tabular}[c]{@{}c@{}}Transparent\\ to the\\ final user\end{tabular} \\ \hline
    \textbf{Stacktrace} &
      yes &
      yes &
      no &
      no &
      yes \\ \hline
    \textbf{Hash} &
      yes &
      no &
      no &
      yes &
      yes \\ \hline
    \end{tabular}
    \caption{Comparison between stacktrace and hash for solving the alignment problem}
    \label{tab:stacktrace_hash_table}
\end{table}

Considering these attempts and their characteristics, it is possible to conclude that they are not suitable as resolution of the alignment problem. In order to give a clear view of their pros and cons, the characteristics of the alternative just discussed are recapped in Table \ref{tab:stacktrace_hash_table}.

\section{Annotations and KSP}\label{section:annotation_ksp}
Since simple Kotlin functionalities are not feasible for solving the alignment problem, another possibility is to try different metaprogramming alternative, such as the ones discussed in Chapter \ref{chapter:metaprogramming}.

The first metaprogramming technique taken in consideration is \textbf{annotations}. As explained in Section \ref{section:annotation}, annotations can be used to create additional metadata to elements in the code, that can be used to create specific behaviors.\newline
This alternative can not be used for a simple reason: the key aspect of this project is the interoperability, achieved by using Kotlin multiplatform, and the chosen targets are Native, JavaScript and JVM; while this thesis is being redacted, Kotlin\\JS does not support annotations, creating a problem that can not be ignored.\newline
Consequently, annotations are excluded from the possible solutions, without concerning about the other necessary characteristics they may provide.

The next alternative that involves metaprogramming is \textbf{KSP}, which is described in details in Section \ref{section:ksp}. Starting from KSP 1.0.1, it is possible to use KSP on multiplatform projects \cite{ksp_multiplatform}, which includes also the targets necessary for the successful outcome desired.\newline
KSP allows the creating of lightweight compilers, providing an API that hides all the complexities that a complete compiler plugin would involve. While designing a possible solution, it is necessary to keep in mind the biggest limitation that this technology brings within, which is the impossibility to modify the source code.\newline
Since KSP can access the code at compile time, it can be used to extract information that can be used to build a custom stacktrace that keeps track of the sequence of functions called. Then, this custom stack can be used as identifier when needed. For this reason, it has been created a class \textit{Stack}, which interface is in Listing \ref{code:stack_interface_ksp}.
\begin{lstlisting}[caption={Stack interface for KSP}, captionpos=b, language=Kotlin, label={code:stack_interface_ksp}]
interface Stack {
    fun currentPath(): String
    fun align(token: String): Unit
}
\end{lstlisting}
By using the \textit{Stack} it is possible to add to a data structure everything necessary for the alignment, which might be for example function calls. Considering the base case cited previously in Listing \ref{code:first_alignment_code_example}, when executing \textit{f1}, the list should contain \textit{[f1, neighboring]}, and when computing \textit{f2} would be \textit{[f2, neighboring]}, making it possible to uniquely identify the two different expressions.\newline
Trying to obtain the result just described, it can be divided in two smaller steps:
\begin{enumerate}
    \item The aggregate programming constructs are part of the DSL functions exposed to the final user, meaning that it is not possible for the user to change their implementation in any way while using it. Moreover, the name of these functions is known in advanced. This leads to create a simple solution for handling them, which consists on changing their implementations and adding a line of code that it is responsible to insert in the \textit{Stack} data structure the function name. For example, in the \textit{neighboring} implementation there is a function call to align that add its name to the stack.
    \item The second problem, which is more complex, can not be solved by in the same way, since it would be the final user to manually solve the alignment problem. The solution would be to modify the functions \textit{f1} and \textit{f2} using KSP and adding the same line of code discussed for the previous case. On the other hand, the direct modification of the source code is not allowed by KSP, which means that the only solution would be to recreate the same code of the user, with the added function calls. This solution would be feasible for simple use cases, but it is not efficient when dealing with complex systems.
\end{enumerate}
This leads to the conclusion that it is crucial for the solution of the alignment problem the possibility to modify the source code. KSP can be used as a temporary solution for some use cases, also taking advantage of the simple and powerful API that it provides, but the downsides are important factors to consider.

\begin{table}[!ht]
    \small
    \centering
    \begin{tabular}{|l|c|c|c|c|c|}
    \hline
    \textbf{} &
      \begin{tabular}[c]{@{}c@{}}Available for\\ Kotlin \\ Multiplatform\end{tabular} &
      \begin{tabular}[c]{@{}c@{}}Allows\\ same target\\ interoperability\end{tabular} &
      \begin{tabular}[c]{@{}c@{}}Allows\\ different targets\\ interoperability\end{tabular} &
      \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Acceptable\\ efficiency\end{tabular}} &
      \begin{tabular}[c]{@{}c@{}}Transparent\\ to the\\ final user\end{tabular} \\ \hline
    \textbf{Stacktrace} & yes & yes                   & no                    & no  & yes \\ \hline
    \textbf{Hash}       & yes & no                    & no                    & yes & yes \\ \hline
    \textbf{Annotation} & no  & -                     & -                     & -   & -   \\ \hline
    \textbf{KSP}        & yes & yes (manually)        & yes (manually)        & no  & no  \\ \hline
    \end{tabular}
    \caption{Comparison between stacktrace, hash, annotation and KSP for solving the alignment problem}
    \label{tab:annotation_ksp_table}
\end{table}

Concluding, the characteristics of annotation and KSP are added in Table \ref{tab:annotation_ksp_table} align side with the stacktrace and hash ones, summarizing the considerations made on all the alternatives considered up until this point.

\section{KCP: solution with total transparency and portability}\label{section:compiler_plugin_solution}
\begin{table}[!ht]
    \small
    \centering
    \begin{tabular}{|l|c|c|c|c|c|}
    \hline
    \textbf{} &
      \begin{tabular}[c]{@{}c@{}}Available for\\ Kotlin \\ Multiplatform\end{tabular} &
      \begin{tabular}[c]{@{}c@{}}Allows\\ same target\\ interoperability\end{tabular} &
      \begin{tabular}[c]{@{}c@{}}Allows\\ different targets\\ interoperability\end{tabular} &
      \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Acceptable\\ efficiency\end{tabular}} &
      \begin{tabular}[c]{@{}c@{}}Transparent\\ to the\\ final user\end{tabular} \\ \hline
    \textbf{Stacktrace} & yes & yes                   & no                    & no  & yes \\ \hline
    \textbf{Hash}       & yes & no                    & no                    & yes & yes \\ \hline
    \textbf{Annotation} & no  & -                     & -                     & -   & -   \\ \hline
    \textbf{KSP}        & yes & yes (manually)        & yes (manually)        & yes & no  \\ \hline
    \textbf{KCP}        & yes & yes                   & yes                   & yes & yes \\ \hline
    \end{tabular}
    \caption{Comparison between stacktrace and hash for solving the alignment problem}
    \label{tab:kcp_table}
\end{table}